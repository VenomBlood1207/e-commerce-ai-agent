"""
LangGraph workflow for orchestrating multi-agent system
"""
from typing import Dict, Any
from langgraph.graph import StateGraph, END
from backend.graph.state import AgentState, create_initial_state
from backend.agents.router_agent import router_agent
from backend.agents.sql_agent import sql_agent
from backend.agents.knowledge_agent import knowledge_agent
from backend.agents.translator_agent import translator_agent
from backend.agents.visualizer_agent import visualizer_agent
from backend.llm.groq_client import groq_client
from backend.memory.conversation_memory import conversation_memory

def response_generator(state: AgentState) -> Dict[str, Any]:
    """
    Generate final response based on agent outputs
    
    Args:
        state: Current agent state
        
    Returns:
        Updated state with final response
    """
    query_type = state.get("query_type")
    error = state.get("error")
    
    # Handle errors
    if error:
        return {
            "response": f"I encountered an error: {error}",
            "response_metadata": {"error": error}
        }
    
    # Handle different query types
    if query_type == "data_query":
        return generate_data_response(state)
    elif query_type == "knowledge_search":
        # Response already generated by knowledge agent
        return {"response_metadata": {"type": "knowledge"}}
    elif query_type == "translation":
        # Response already generated by translator agent
        return {"response_metadata": {"type": "translation"}}
    elif query_type == "utility":
        return generate_utility_response(state)
    
    return {"response": "I'm not sure how to help with that."}

def generate_data_response(state: AgentState) -> Dict[str, Any]:
    """Generate response for data queries"""
    result_df_dict = state.get("result_dataframe")
    sql_query = state.get("sql_query")
    
    if not result_df_dict or not result_df_dict.get("data"):
        return {
            "response": "I couldn't find any data matching your query.",
            "response_metadata": {"type": "data", "has_results": False}
        }
    
    # Generate natural language response
    row_count = result_df_dict.get("row_count", 0)
    
    prompt = f"""Generate a friendly, conversational response to the user's question based on the query results.

User's Question: {state['user_query']}
Number of Results: {row_count}
Sample Data: {str(result_df_dict['data'][:3])}

Guidelines:
- Start with "Based on your question..." or "According to the data..." or similar natural phrases
- DO NOT say "I found X results for your query"
- Be conversational and helpful
- Highlight 1-2 key insights from the data
- Keep it concise (2-3 sentences)

Example good responses:
- "Based on your question about top cities, São Paulo leads with 15,540 orders, followed by Rio de Janeiro with 6,882 orders."
- "According to the sales data, the top 5 categories generated over $1.2M in revenue, with furniture being the highest performer."
- "Looking at the delivery patterns, most orders are concentrated in the Southeast region, particularly in São Paulo and Rio de Janeiro."

Generate a similar natural, helpful response:"""

    try:
        nl_response = groq_client.generate_response(prompt, temperature=0.4)
    except:
        nl_response = f"Based on your question, I found {row_count} relevant results in the database."
    
    return {
        "response": nl_response,
        "response_metadata": {
            "type": "data",
            "has_results": True,
            "row_count": row_count
        }
    }

def generate_utility_response(state: AgentState) -> Dict[str, Any]:
    """Generate response for utility queries"""
    query_lower = state["user_query"].lower()
    
    if any(greeting in query_lower for greeting in ["hello", "hi", "hey"]):
        response = """Hello! I'm your E-commerce Intelligence Assistant. I can help you:

• Analyze sales data and trends
• Find information about products and categories
• Translate Portuguese category names
• Generate visualizations from data

What would you like to know?"""
    
    elif any(word in query_lower for word in ["help", "what can you do", "capabilities"]):
        response = """I can assist you with:

**Data Analysis:**
- Sales trends and revenue analysis
- Customer behavior insights
- Product performance metrics
- Delivery time analysis

**Knowledge Search:**
- Product information
- Category details
- Market trends

**Utilities:**
- Portuguese ↔ English translation
- Data visualization

Just ask me a question in natural language!"""
    
    else:
        response = "I'm here to help! Ask me about sales data, products, or anything related to the e-commerce dataset."
    
    return {
        "response": response,
        "response_metadata": {"type": "utility"}
    }

def should_visualize(state: AgentState) -> str:
    """Determine if visualization should be generated"""
    query_type = state.get("query_type")
    result_df = state.get("result_dataframe")
    
    if query_type == "data_query" and result_df and result_df.get("data"):
        return "visualize"
    return "respond"

def route_query(state: AgentState) -> str:
    """Route to appropriate agent based on query type"""
    query_type = state.get("query_type", "data_query")
    
    if query_type == "data_query":
        return "sql"
    elif query_type == "knowledge_search":
        return "knowledge"
    elif query_type == "translation":
        return "translate"
    else:
        return "respond"

def create_workflow() -> StateGraph:
    """
    Create the LangGraph workflow
    
    Returns:
        Compiled workflow graph
    """
    # Create graph
    workflow = StateGraph(AgentState)
    
    # Add nodes
    workflow.add_node("router", router_agent)
    workflow.add_node("sql", sql_agent)
    workflow.add_node("knowledge", knowledge_agent)
    workflow.add_node("translate", translator_agent)
    workflow.add_node("visualize", visualizer_agent)
    workflow.add_node("respond", response_generator)
    
    # Set entry point
    workflow.set_entry_point("router")
    
    # Add conditional edges from router
    workflow.add_conditional_edges(
        "router",
        route_query,
        {
            "sql": "sql",
            "knowledge": "knowledge",
            "translate": "translate",
            "respond": "respond"
        }
    )
    
    # Add edges from agents to visualization check
    workflow.add_conditional_edges(
        "sql",
        should_visualize,
        {
            "visualize": "visualize",
            "respond": "respond"
        }
    )
    
    # Add edges from other agents to response
    workflow.add_edge("knowledge", "respond")
    workflow.add_edge("translate", "respond")
    workflow.add_edge("visualize", "respond")
    
    # Add edge from response to end
    workflow.add_edge("respond", END)
    
    # Compile workflow
    return workflow.compile()

# Global workflow instance
agent_workflow = create_workflow()

async def process_query(user_query: str, session_id: str = "default") -> Dict[str, Any]:
    """
    Process user query through the workflow
    
    Args:
        user_query: User's query
        session_id: Session identifier
        
    Returns:
        Final state with response
    """
    # Create initial state
    initial_state = create_initial_state(user_query, session_id)
    
    # Add conversation context
    context = conversation_memory.get_context_summary(session_id)
    initial_state["conversation_context"] = context
    
    # Run workflow
    final_state = agent_workflow.invoke(initial_state)
    
    # Save to conversation memory
    conversation_memory.add_message(
        session_id=session_id,
        role="user",
        content=user_query
    )
    
    conversation_memory.add_message(
        session_id=session_id,
        role="assistant",
        content=final_state.get("response", ""),
        metadata={
            "query_type": final_state.get("query_type"),
            "sql_query": final_state.get("sql_query"),
            "chart_type": final_state.get("chart_type")
        }
    )
    
    return final_state
